﻿﻿﻿# 【UTC】CentOS7修改时区的正确姿势原文链接：https://www.jianshu.com/p/ab82790836df---## 时钟概念### （1）UTC整个地球分为二十四时区，每个时区都有自己的本地时间。在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时(UTC,Universal Time Coordinated)。### （2）GMT格林威治标准时间 (Greenwich Mean Time)指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。(UTC与GMT时间基本相同，本文中不做区分)### （3）CST中国标准时间 (China Standard Time)【GMT + 8 = UTC + 8 = CST】### （4）DST夏令时(Daylight Saving Time) 指在夏天太阳升起的比较早时，将时钟拨快一小时，以提早日光的使用。（中国不使用）## 硬件时钟：RTC(Real-Time Clock)或CMOS时钟，一般在主板上靠电池供电，服务器断电后也会继续运行。仅保存日期时间数值，无法保存时区和夏令时设置。## 系统时钟：一般在服务器启动时复制RTC时间，之后独立运行，保存了时间、时区和夏令时设置。在CentOS 6版本，时间设置有date、hwclock命令，从CentOS 7开始，使用了一个新的命令timedatectl。Centos7 修改系统时区timezone  ，解决快、慢8小时问题。如果服务器用非 UTC 的时间，时区转换很容易不一致，而且对于有 daylight saving 的时区，每年多一小时少一小时的那两天，系统就会出现各种诡异现象。服务器使用UTC时间，如要显示用户所在时区的本地时间，在客户端转化即可。## 一、查看服务器使用的时间类型```# timedatectl``````      Local time: Wed 2020-01-15 04:10:58 EST  Universal time: Wed 2020-01-15 09:10:58 UTC        RTC time: Wed 2020-01-15 17:01:48       Time zone: America/New_York (EST, -0500)     NTP enabled: yesNTP synchronized: yes RTC in local TZ: no      DST active: no Last DST change: DST ended at                  Sun 2019-11-03 01:59:59 EDT                  Sun 2019-11-03 01:00:00 EST Next DST change: DST begins (the clock jumps one hour forward) at                  Sun 2020-03-08 01:59:59 EST                  Sun 2020-03-08 03:00:00 EDT```我们可以看到，服务器使用的CST 时间## 二、将服务器时间类型改为UTC### 方法一：```# timedatectl  set-timezone UTC#  timedatectl set-time "YYYY-MM-DD HH:MM:SS"#  timedatectl set-time   "HH:MM:SS"# timedatectl```我们可以看到，服务器时间类型更改为UTC了```# ll   /etc/locatimelrwxrwxrwx. 1 root root 25 1月  14 08:30 /etc/localtime -> ../usr/share/zoneinfo/UTC```实际上是做了一个将  文件  /etc/localtime  做了一个软连接到 /usr/share/zoneinfo/UTC### 方法二：```#  ln  -s   /usr/share/zoneinfo/UTC    /etc/localtime```ln: 无法创建符号链接"/etc/localtime": 文件已存在```#  ln  -sf /usr/share/zoneinfo/UTC    /etc/localtime```做软连接时，需要加 -f 参数，强制覆盖，不然会显示软链接已存在```#  timedatectl set-time "YYYY-MM-DD HH:MM:SS"#  timedatectl set-time   "HH:MM:SS"    //只设置时分秒# timedatectl```## 三、将系统时间写入硬件CMOS```#  clock  -w#  date   -u    //显示UTC时间```CentOS7修改时区的正确姿势CentOS7上运行Java程序，发现程序生成的时间与当前时间匹配不上，还以为是数据停止更新了，后来发现没有正确使用修改时区的姿势，导致程序时区错误。正确的修改CentOS7 时区的姿势：```#   ln -sf /usr/share/zoneinfo/Asia/Shanghai    /etc/localtime```其他系统的修改文件可能是/var/etc/localtime.错误的姿势：通过cp命令覆盖/etc/localtime时间```#  cp -f /usr/share/zoneinfo/Asia/Shanghai    /etc/localtime```通过cp命令修改时区，通过date, data -R命令显示的时区都是正确的，可是对于java程序而言，是错误的。具体原因在于Java访问系统时区的方式上，可参见文章：Java TimeZone 和 Linux TimeZone问题https://my.oschina.net/huawu/blog/4646该文章很好的说明了Java访问系统时区的方式：1. 如有环境变量 TZ设置，则用TZ中设置的时区2. 在 /etc/sysconfig/clock文件中找 “ZONE”的值3. 如何2)都没，就用/etc/localtime 和 /usr/share/zoneinfo 下的时区文件进行匹配，如找到匹配的，就返回对应的路径和文件名。 问题在于，如果使用cp命令来修改/etc/localtime文件，那么可能就会导致修改的不是/etc/localtime文件，而是原时区的文件内容。/etc/localtime是通过符号链接链接/usr/share/zoneinfo下的文件，而java是通过文件名来确认时区的，data命令是通过文件内容确认时区的，这样就导致了data命令时区正确，而java的时区是错误的！```# ll /etc/localtime lrwxrwxrwx 1 root root 35 Jan 15 17:13 /etc/localtime -> ../usr/share/zoneinfo/Asia/Shanghai# cat /etc/localtimeCST-8# cat /usr/share/zoneinfo/Asia/ShanghaiCST-8#```如上图所示：CentOS7是通过符号链接到/usr/share/zoneinfo/下的时区文件的，如果通过cp指令只会修改原时区文件内容，这样，通过date的系统命令，查看时间是OK的，可是java是通过读取文件名的方式确认时区信息的。所以时区还是纽约。